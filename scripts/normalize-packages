#!/usr/bin/env node

const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')
const sortedObject = require('sorted-object')
const { getPackages, readFile, writeFile, unlink } = require('./utils')

const deleteProperties = (object, property, properties) => {
  const nestedObject = object[property]
  if (nestedObject === undefined) {
    return
  }
  properties.forEach(property => {
    delete nestedObject[property]
  })
  if (isEmpty(object[property])) {
    delete object[property]
  }
}

require('exec-promise')(() =>
  getPackages(true).map(({ dir, name, package: pkg, relativeDir }) => {
    // consider packages as private by default to avoid publishing them by mistake
    if (!('private' in pkg)) {
      pkg.private = true
    }

    pkg.name = name
    pkg.homepage = `https://github.com/vatesfr/xen-orchestra/tree/master/${relativeDir}`
    pkg.bugs = `https://github.com/vatesfr/xen-orchestra/issues`
    pkg.repository = {
      directory: relativeDir,
      type: 'git',
      url: 'https://github.com/vatesfr/xen-orchestra.git',
    }

    if (!('version' in pkg)) {
      pkg.version = '0.0.0'
    }
    pkg.engines = {
      node: '>=8.10',
      ...pkg.engines,
    }

    delete pkg.husky
    delete pkg.standard
    delete pkg['lint-staged']

    deleteProperties(pkg, 'config', ['commitizen'])
    deleteProperties(pkg, 'devDependencies', [
      'babel-7-jest',
      'babel-eslint',
      'babel-jest',
      'commitizen',
      'cz-conventional-changelog',
      'dependency-check',
      'eslint',
      'eslint-config-prettier',
      'eslint-config-standard',
      'eslint-plugin-import',
      'eslint-plugin-node',
      'eslint-plugin-promise',
      'eslint-plugin-standard',
      'flow-bin',
      'ghooks',
      'husky',
      'jest',
      'lint-staged',
      'prettier',
      'standard',
    ])
    deleteProperties(pkg, 'scripts', ['commitmsg', 'cz'])

    let { scripts = {} } = pkg
    const originalScripts = scripts

    if (!pkg.private && !('postversion' in scripts)) {
      scripts = { ...scripts, postversion: 'npm publish --access public' }
    }

    const prepublish = scripts.prepublish
    if (prepublish !== undefined && !('prepublishOnly' in scripts)) {
      scripts = {
        ...scripts,
        prepublishOnly: prepublish,
        prepublish: undefined,
      }
    }

    if (scripts !== originalScripts) {
      pkg.scripts = sortedObject(scripts)
    }

    return Promise.all([
      readFile(`${dir}/README.md`, 'utf8')
        .then(content => {
          const data = {
            pkg: {
              ...pkg,
              author: {
                name: 'Vates SAS',
                url: 'https://vates.fr',
              },
            },
          }
          return writeFile(
            `${dir}/README.md`,
            content.replace(
              /\$\{([^}]+)\}/g,
              (_, path) => get(data, path, _) || _
            )
          )
        })
        .catch(error => {
          console.error('Error while handling README', error)
        }),
      writeFile(`${dir}/package.json`, JSON.stringify(pkg, null, 2) + '\n'),
      unlink(`${dir}/.editorconfig`),
      unlink(`${dir}/.eslintrc.js`),
      unlink(`${dir}/.flowconfig`),
      unlink(`${dir}/.gitignore`),
      unlink(`${dir}/.jshintrc`),
      unlink(`${dir}/.prettierrc.js`),
      unlink(`${dir}/.travis.yml`),
      unlink(`${dir}/ISSUE_TEMPLATE.lock`),
      unlink(`${dir}/package-lock.json`),
      unlink(`${dir}/yarn.lock`),
    ])
  })
)
